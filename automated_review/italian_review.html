<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFBench Italian Auto Review</title>
    <link rel="stylesheet" href="css/validator.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid #356854;
            margin-bottom: 30px;
        }

        header h1 {
            color: #4ecca3;
            font-size: 2em;
            margin-bottom: 10px;
        }

        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(78, 204, 163, 0.2);
        }

        .panel h2 {
            color: #4ecca3;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(78, 204, 163, 0.3);
            font-size: 1.3em;
        }

        .upload-zone {
            border: 2px dashed rgba(78, 204, 163, 0.4);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-zone:hover {
            border-color: #4ecca3;
            background: rgba(78, 204, 163, 0.1);
        }

        .upload-zone input { display: none; }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary { background: #4ecca3; color: #1a1a2e; }
        .btn-secondary { background: #555; color: #fff; }
        .btn-danger { background: #e74c3c; color: #fff; }
        .btn:hover { transform: scale(1.02); opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .progress-bar-wrapper {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ecca3, #45b393);
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #1a1a2e;
        }

        .log-area {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.85em;
        }

        .log-entry { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .log-entry.success { color: #2ecc71; }
        .log-entry.error { color: #e74c3c; }
        .log-entry.info { color: #3498db; }

        .result-card {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .result-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .result-header:hover { background: rgba(78, 204, 163, 0.1); }

        .badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-pass { background: #2ecc71; color: #000; }
        .badge-fail { background: #e74c3c; color: #fff; }

        .rating-badge {
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .rating-5 { background: #2ecc71; color: #000; }
        .rating-4 { background: #3498db; color: #fff; }
        .rating-3 { background: #f39c12; color: #000; }
        .rating-2 { background: #e74c3c; color: #fff; }
        .rating-1 { background: #8e44ad; color: #fff; }

        .result-content {
            display: none;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .result-content.active { display: block; }

        .result-feedback {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            white-space: pre-wrap;
            line-height: 1.6;
        }

        .summary-box {
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .summary-box.approved { background: rgba(46, 204, 113, 0.2); border: 2px solid #2ecc71; }
        .summary-box.revision { background: rgba(243, 156, 18, 0.2); border: 2px solid #f39c12; }
        .summary-box.rejected { background: rgba(231, 76, 60, 0.2); border: 2px solid #e74c3c; }

        .summary-box h2 { font-size: 1.8em; margin-bottom: 15px; border: none; padding: 0; }
        .summary-box.approved h2 { color: #2ecc71; }
        .summary-box.revision h2 { color: #f39c12; }
        .summary-box.rejected h2 { color: #e74c3c; }

        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .stat-value { font-size: 2em; font-weight: bold; color: #4ecca3; }
        .stat-label { color: #888; font-size: 0.9em; }

        .feedback-output {
            white-space: pre-wrap;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            color: #ccc;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
        }

        .cells-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .cell-tag {
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85em;
        }

        .cell-tag.found { background: rgba(46, 204, 113, 0.3); color: #2ecc71; }
        .cell-tag.missing { background: rgba(231, 76, 60, 0.3); color: #e74c3c; }

        .hidden { display: none; }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(78, 204, 163, 0.3);
            border-radius: 50%;
            border-top-color: #4ecca3;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>CFBench Italian Auto Review</h1>
            <p style="color: #888; margin-bottom: 15px;">Automated evaluation for Italian language tasks</p>
            <span class="api-status" id="api-status">
                <span class="spinner"></span> Loading API...
            </span>
        </header>

        <!-- Upload Section -->
        <div class="panel" id="upload-panel">
            <h2>Upload Task File</h2>
            <div class="upload-zone" onclick="document.getElementById('file-input').click()">
                <div style="font-size: 3em; margin-bottom: 15px;">üìÑ</div>
                <p>Drop your .py task file here or click to browse</p>
                <input type="file" id="file-input" accept=".py" onchange="handleFileUpload(event)">
            </div>
            <div id="file-info" class="hidden" style="margin-top: 20px;">
                <p style="color: #4ecca3;"><strong>File:</strong> <span id="file-name"></span></p>
                <div class="cells-preview" id="cells-preview"></div>
                <button class="btn btn-primary" style="margin-top: 20px; width: 100%;" onclick="startAnalysis()">
                    üöÄ Start Italian Review
                </button>
            </div>
        </div>

        <!-- Progress Section -->
        <div class="panel hidden" id="progress-panel">
            <h2>Analysis in Progress</h2>
            <div class="progress-bar-wrapper">
                <div class="progress-bar" id="progress-bar" style="width: 0%">0%</div>
            </div>
            <p id="progress-status" style="text-align: center; color: #888; margin-bottom: 15px;">Preparing...</p>
            <div class="log-area" id="log-area"></div>
            <button class="btn btn-danger" style="margin-top: 15px;" onclick="cancelAnalysis()">Cancel</button>
        </div>

        <!-- Results Section -->
        <div class="panel hidden" id="results-panel">
            <h2>Analysis Results</h2>

            <div class="summary-box" id="summary-box">
                <h2 id="verdict-text">Analyzing...</h2>
                <p id="verdict-message"></p>
                <div class="summary-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-avg">-</div>
                        <div class="stat-label">Average Rating</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-pass">-</div>
                        <div class="stat-label">Passed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-fail">-</div>
                        <div class="stat-label">Failed</div>
                    </div>
                </div>
            </div>

            <div id="results-list"></div>

            <!-- Difficulty & Review Time -->
            <div style="margin-top: 20px; display: flex; gap: 20px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 200px;">
                    <label style="color: #4ecca3; font-weight: bold;">Difficulty:</label>
                    <select id="difficulty-select" style="width: 100%; padding: 10px; margin-top: 5px; background: rgba(0,0,0,0.3); border: 1px solid #4ecca3; border-radius: 8px; color: #fff;">
                        <option value="Easy">Easy</option>
                        <option value="Medium">Medium</option>
                        <option value="Hard" selected>Hard</option>
                    </select>
                </div>
                <div style="flex: 1; min-width: 200px;">
                    <label style="color: #4ecca3; font-weight: bold;">Review Time (minutes):</label>
                    <input type="number" id="review-time" value="15" min="1" max="120" style="width: 100%; padding: 10px; margin-top: 5px; background: rgba(0,0,0,0.3); border: 1px solid #4ecca3; border-radius: 8px; color: #fff;">
                </div>
            </div>
            <div style="margin-top: 15px;">
                <label style="color: #4ecca3; font-weight: bold;">Difficulty Reason:</label>
                <textarea id="difficulty-reason" rows="2" placeholder="e.g., Exact word count constraint, no commas, indicative mood only..." style="width: 100%; padding: 10px; margin-top: 5px; background: rgba(0,0,0,0.3); border: 1px solid #4ecca3; border-radius: 8px; color: #fff; resize: vertical;"></textarea>
            </div>

            <div style="margin-top: 20px;">
                <h3 style="color: #4ecca3; margin-bottom: 15px;">Complete Feedback</h3>
                <div class="feedback-output" id="feedback-output"></div>
                <button class="btn btn-primary" style="margin-top: 15px;" onclick="generateFinalFeedback()">Generate Final Feedback</button>
                <button class="btn btn-primary" style="margin-top: 15px;" onclick="copyFeedback()">Copy Feedback</button>
                <button class="btn btn-secondary" style="margin-top: 15px;" onclick="resetTool()">Review Another</button>
            </div>
        </div>
    </div>

    <!-- Load existing config and API handler -->
    <script src="config.js"></script>
    <script src="js/api_handler.js"></script>

    <script>
        // State
        let apiHandler = null;
        let fileContent = '';
        let fileName = '';
        let extractedCells = {};
        let analysisResults = {};
        let isAnalyzing = false;

        // Official CFBench Criteria - OPTIMIZED: Each criterion receives ONLY the cells it needs
        const italianCriteria = [
            {
                id: 'problem_framing',
                name: 'CFBench Problem Framing and Motivation',
                min: 5,
                // NEEDS: system + user_all_turns
                prompt: `Evaluate PROBLEM FRAMING. Does the task have clear motivation?

{CONTEXT}

CHECK:
- Who is the user? (role, profession)
- What do they want? (specific request)
- Why do they need help?

RATING:
5 = Clear identity + specific request + realistic scenario (e.g., "Mi chiamo Marco, food blogger, devo pubblicare...")
4 = Clear but one element underdeveloped
3 = Generic request, unclear context
2 = Vague request
1 = No motivation

JSON only: {"rating": 1-5, "feedback": "one sentence", "issues": []}`
            },
            {
                id: 'system_message',
                name: 'System Message Correctness (Italian)',
                min: 5,
                // NEEDS: system ONLY
                prompt: `Evaluate SYSTEM MESSAGE Italian quality.

{CONTEXT}

CHECK:
1. Grammar correct? (conjugations, agreements)
2. Formality consistent? (ALL tu OR ALL Lei)
3. Anglicisms? (e.g., "performare" instead of "eseguire")
4. Natural to native speaker?

RATING:
5 = Flawless Italian, consistent formality, no anglicisms
4 = Minor awkward phrases, grammar correct
3 = Mixed tu/Lei or minor grammar errors
2 = Frequent errors, heavy anglicisms
1 = Broken, machine-translated

JSON only: {"rating": 1-5, "feedback": "one sentence", "issues": []}`
            },
            {
                id: 'instruction_alignment',
                name: 'Instruction Alignment and Conflict Coverage',
                min: 5,
                // NEEDS: turn_metadata + user_final
                prompt: `Check if ALL CONSTRAINTS from metadata appear in user query.

{CONTEXT}

EXAMPLES of explicit constraints:
- "377 parole" or "trecentosettantasette parole" ‚úì
- "4 paragrafi" ‚úì
- "non usare virgole" ‚úì
- "usa le parole: X, Y, Z" ‚úì

RATING:
5 = ALL constraints explicit in Italian query
4 = All present, slightly unnatural phrasing
3 = Some missing or awkward
2 = Multiple hidden in metadata
1 = Constraints absent or wrong language

JSON only: {"rating": 1-5, "feedback": "one sentence", "missing_constraints": [], "issues": []}`
            },
            {
                id: 'factual_accuracy',
                name: 'Factual Accuracy and Hallucination (Italian Context)',
                min: 5,
                // NEEDS: user_all_turns + assistant
                prompt: `Check for HALLUCINATION. Does golden ONLY use user-provided data?

{CONTEXT}

CRITICAL: Every fact in golden must trace back to user data. No invented info.

RATING:
5 = ZERO hallucination. All facts from user data.
4 = One minor inferred detail
3 = Some added information
2 = Significant hallucination
1 = Fabricated response

JSON only: {"rating": 1-5, "feedback": "one sentence", "issues": []}`
            },
            {
                id: 'response_formatting',
                name: 'Response Formatting & Cleanup (Italian)',
                min: 4,
                // NEEDS: assistant ONLY
                prompt: `Check for Italian PREAMBLES/CLOSURES.

{CONTEXT}

FORBIDDEN START: "Certo!", "Ecco la risposta:", "Perfetto!", "Con piacere!"
FORBIDDEN END: "Spero di averti aiutato!", "Non esitare a chiedere!", "Fammi sapere!"

RATING:
5 = CLEAN. Starts directly with content. No fillers.
4 = One brief "Ecco" but clean
3 = One preamble OR one closure
2 = Multiple fillers
1 = Excessive verbosity

JSON only: {"rating": 1-5, "feedback": "one sentence", "preambles_found": [], "issues": []}`
            },
            {
                id: 'dialogue_realisticness',
                name: 'Dialogue Realisticness (Italian Native Feel)',
                min: 4,
                // NEEDS: system + user_final + assistant
                prompt: `Does dialogue sound NATURAL to native Italian speaker?

{CONTEXT}

CHECK:
1. Native speaker feel?
2. Natural expressions? (a quanto pare, per quanto riguarda)
3. Correct congiuntivo? (credo che sia, NOT credo che √®)
4. Anglicisms/calques?
5. Register consistent? (tu/Lei)

RATING:
5 = Native feel. Natural expressions, correct congiuntivo.
4 = Good. Minor textbook phrasing.
3 = Noticeable translated feel.
2 = Awkward, robotic.
1 = Machine translation obvious.

JSON only: {"rating": 1-5, "feedback": "one sentence", "register": "tu/Lei/mixed", "issues": []}`
            },
            {
                id: 'model_breaking',
                name: 'Model Breaking Success',
                min: 4,
                // NEEDS: model_validators ONLY
                prompt: `Analyze MODEL BREAKING. Do model passes fail enough constraints?

{CONTEXT}

STEP 1 - For EACH model pass (nemotron_1 to nemotron_4):
- Count TOTAL constraints (ALL types: IF like detectable_format, keywords + LLM Eval like stylistic, linguistic + llm_judge)
- Count FAILED constraints
- Calculate failure rate: failed √∑ total = X%

STEP 2 - Count how many of the 4 passes have failure rate >= 50%

STEP 3 - Check VARIANCE: Does at least ONE constraint show BOTH Pass AND Fail across different passes?

RATING (FOLLOW EXACTLY - this is from official guidelines):
5 = PERFECT: 4/4 passes have FAIL>=50% AND variance exists
4 = STRONG: Exactly 3/4 passes have FAIL>=50%, 1/4 has FAIL<50% AND variance exists
3 = WEAK: 2/4 passes have FAIL<50% (so only 2/4 have FAIL>=50%)
2 = TOO EASY: 3/4 or 4/4 passes have FAIL<50% but some constraints DO fail
1 = FAILED: 4/4 passes have FAIL<50% AND almost nothing fails

EXAMPLE: Pass fails 3/7 constraints = 42.8%. If all 4 passes are like this (42.8% < 50%), Rating = 2

JSON only: {"rating": 1-5, "feedback": "X/4 passes FAIL>=50%. Each pass: Y/Z failed (W%)", "issues": []}`
            },
            {
                id: 'golden_perfection',
                name: 'Golden Response Perfection (Italian Quality)',
                min: 5,
                // NEEDS: assistant + turn_metadata + validator_assistant
                prompt: `Evaluate GOLDEN RESPONSE quality.

{CONTEXT}

IMPORTANT: Validator results show PASSED/FAILED. Trust them.

CHECK:
1. Validator shows ALL PASSED?
2. Italian impeccable? (grammar, punctuation)
3. Italian editor would approve?

RATING:
5 = ALL PASSED + impeccable Italian
4 = All passed + minor awkward phrase
3 = Passed but textbook-ish
2 = FAILED constraint OR Italian errors
1 = Multiple failures OR broken Italian

JSON only: {"rating": 1-5, "feedback": "one sentence", "issues": []}`
            }
        ];

        // Initialize
        window.onload = function() {
            apiHandler = new APIHandler();
            updateApiStatus();
        };

        function updateApiStatus() {
            const status = document.getElementById('api-status');
            if (apiHandler && apiHandler.hasApiKey()) {
                status.innerHTML = `‚úì API Connected (${apiHandler.getRemainingCalls()} calls left)`;
                status.style.background = 'rgba(46, 204, 113, 0.2)';
                status.style.color = '#2ecc71';
            } else {
                status.innerHTML = '‚úó API Key Missing - check config.js';
                status.style.background = 'rgba(231, 76, 60, 0.2)';
                status.style.color = '#e74c3c';
            }
        }

        // File handling
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            fileName = file.name;
            document.getElementById('file-name').textContent = fileName;

            const reader = new FileReader();
            reader.onload = function(e) {
                fileContent = e.target.result;
                extractCells();
                document.getElementById('file-info').classList.remove('hidden');
            };
            reader.readAsText(file);
        }

        function extractCells() {
            extractedCells = {};

            // Patterns
            const patterns = {
                system: /\*\*\[system\]\*\*\s*([\s\S]*?)(?=\*\*\[|$)/,
                user: /\*\*\[user\]\*\*\s*([\s\S]*?)(?=\*\*\[|$)/g,
                thinking: /\*\*\[thinking\]\*\*\s*([\s\S]*?)(?=\*\*\[|$)/g,
                assistant: /\*\*\[assistant\]\*\*\s*([\s\S]*?)(?=\*\*\[|$)/g,
                turn_metadata: /\*\*\[turn_metadata\]\*\*\s*```json\s*([\s\S]*?)```/,
                validator_assistant: /\*\*\[validator_assistant\]\*\*\s*```\s*([\s\S]*?)```/,
                validator_human: /\*\*\[validator_human\]\*\*\s*```\s*([\s\S]*?)```/,
                model_validators: /\*\*\[validator_assistant_(qwen|nemotron)_\d\]\*\*[\s\S]*?```[\s\S]*?([\s\S]*?)```/g
            };

            // Extract
            const systemMatch = fileContent.match(patterns.system);
            if (systemMatch) extractedCells.system = systemMatch[1].trim();

            const userMatches = [...fileContent.matchAll(patterns.user)];
            if (userMatches.length > 0) {
                extractedCells.user_final = userMatches[userMatches.length - 1][1].trim();
                // For multi-turn: combine ALL user turns for factual accuracy check
                extractedCells.user_all_turns = userMatches.map(m => m[1].trim()).join('\n\n---TURN---\n\n');
            }

            const thinkingMatches = [...fileContent.matchAll(patterns.thinking)];
            if (thinkingMatches.length > 0) {
                extractedCells.thinking = thinkingMatches[thinkingMatches.length - 1][1].trim();
            }

            const assistantMatches = [...fileContent.matchAll(patterns.assistant)];
            if (assistantMatches.length > 0) {
                extractedCells.assistant = assistantMatches[assistantMatches.length - 1][1].trim();
            }

            const metadataMatch = fileContent.match(patterns.turn_metadata);
            if (metadataMatch) {
                extractedCells.turn_metadata = metadataMatch[1].trim();
                try {
                    extractedCells.metadata_json = JSON.parse(metadataMatch[1]);
                } catch (e) {}
            }

            const vaMatch = fileContent.match(patterns.validator_assistant);
            if (vaMatch) extractedCells.validator_assistant = vaMatch[1].trim();

            const vhMatch = fileContent.match(patterns.validator_human);
            if (vhMatch) extractedCells.validator_human = vhMatch[1].trim();

            const modelValidatorMatches = [...fileContent.matchAll(patterns.model_validators)];
            if (modelValidatorMatches.length > 0) {
                extractedCells.model_validators = modelValidatorMatches.map(m => m[2]).join('\n---\n');
            }

            // Validate cell order
            const orderIssues = validateCellOrder();

            // Update preview
            const preview = document.getElementById('cells-preview');
            const cells = ['system', 'user_final', 'thinking', 'turn_metadata', 'assistant', 'validator_assistant', 'model_validators'];
            preview.innerHTML = cells.map(c =>
                `<span class="cell-tag ${extractedCells[c] ? 'found' : 'missing'}">${extractedCells[c] ? '‚úì' : '‚úó'} ${c}</span>`
            ).join('');

            // Show order validation result
            if (orderIssues.length > 0) {
                preview.innerHTML += `<br><span class="cell-tag missing" style="margin-top: 10px;">‚ö†Ô∏è Order issues: ${orderIssues.join(', ')}</span>`;
            } else {
                preview.innerHTML += `<br><span class="cell-tag found" style="margin-top: 10px;">‚úì Cell order is correct</span>`;
            }

            // Word counts with dynamic requirements
            const wordCounts = validateMetadataWordCounts();
            let wordCountHtml = '<br><div style="margin-top: 10px; color: #888;">üìä Word counts: ';
            wordCounts.forEach((w, i) => {
                if (i > 0) wordCountHtml += ' | ';
                if (w.required) {
                    // Has requirement - show comparison
                    const icon = w.status === 'pass' ? '‚úì' : '‚úó';
                    const color = w.status === 'pass' ? '#4ecca3' : '#ff6b6b';
                    const relationSymbol = w.relation === 'at least' ? '‚â•' :
                                          w.relation === 'at most' ? '‚â§' :
                                          w.relation === 'less than' ? '<' :
                                          w.relation === 'more than' ? '>' : '=';
                    wordCountHtml += `<span style="color: ${color}">${w.label}: ${w.actual}/${w.required} ${relationSymbol} ${icon}</span>`;
                } else {
                    // No requirement - just show count
                    wordCountHtml += `${w.label}: ${w.actual}`;
                }
            });
            wordCountHtml += '</div>';
            preview.innerHTML += wordCountHtml;
        }

        // Italian-specific word count (from word_count.html - handles elisions like l'amico = 2 words)
        function countItalianWords(text) {
            if (!text) return 0;
            const tokens = tokenizarItaliano(text);
            return tokens.length;
        }

        function tokenizarItaliano(text) {
            const ITALIAN_CHARS = "a-zA-Z√†√®√©√¨√≤√π√Ä√à√â√å√í√ô";
            const tokens = [];
            const regex = new RegExp(`([${ITALIAN_CHARS}]+')([${ITALIAN_CHARS}]+)|([${ITALIAN_CHARS}]+)`, 'gi');

            let match;
            while ((match = regex.exec(text)) !== null) {
                if (match[1] && match[2]) {
                    // Elision: l'amico -> l' + amico = 2 tokens
                    tokens.push({ text: match[1], type: 'elision' });
                    tokens.push({ text: match[2], type: 'word' });
                } else if (match[3]) {
                    tokens.push({ text: match[3], type: 'word' });
                }
            }
            return tokens;
        }

        // Count words and compare against metadata requirements (if they exist)
        function validateMetadataWordCounts() {
            const metadata = extractedCells.turn_metadata || '';
            const results = [];

            // Extract length requirements from metadata
            const requirements = extractLengthRequirements(metadata);

            // System prompt
            const systemActual = countItalianWords(extractedCells.system || '');
            results.push({
                label: 'System',
                actual: systemActual,
                required: requirements.system,
                status: requirements.system ? (systemActual >= requirements.system ? 'pass' : 'fail') : 'info'
            });

            // User prompt (final turn)
            const userActual = countItalianWords(extractedCells.user_final || '');
            results.push({
                label: 'User',
                actual: userActual,
                required: requirements.user,
                status: requirements.user ? (userActual >= requirements.user ? 'pass' : 'fail') : 'info'
            });

            // Golden response - check against number_words constraint if exists
            const goldenActual = countItalianWords(extractedCells.assistant || '');
            const goldenReq = extractGoldenWordRequirement(metadata);
            results.push({
                label: 'Golden',
                actual: goldenActual,
                required: goldenReq ? goldenReq.value : null,
                relation: goldenReq ? goldenReq.relation : null,
                status: goldenReq ? checkWordConstraint(goldenActual, goldenReq.value, goldenReq.relation) : 'info'
            });

            return results;
        }

        // Extract system/user length requirements from metadata
        function extractLengthRequirements(metadata) {
            const req = { system: null, user: null };

            // Look for system_prompt_length or similar
            const systemMatch = metadata.match(/system[_\s]?prompt[_\s]?(?:length|words?)["\s:]+(\d+)/i) ||
                               metadata.match(/"system_words"\s*:\s*(\d+)/i);
            if (systemMatch) req.system = parseInt(systemMatch[1]);

            // Look for user_prompt_length or similar
            const userMatch = metadata.match(/user[_\s]?prompt[_\s]?(?:length|words?)["\s:]+(\d+)/i) ||
                             metadata.match(/"user_words"\s*:\s*(\d+)/i);
            if (userMatch) req.user = parseInt(userMatch[1]);

            return req;
        }

        // Extract golden response word count requirement
        function extractGoldenWordRequirement(metadata) {
            // Look for number_words constraint
            const numWordsMatch = metadata.match(/"instruction_id"\s*:\s*"[^"]*number_words[^"]*"[^}]*"num_words"\s*:\s*(\d+)[^}]*(?:"relation"\s*:\s*"([^"]+)")?/);
            if (numWordsMatch) {
                return {
                    value: parseInt(numWordsMatch[1]),
                    relation: numWordsMatch[2] || 'equal to'
                };
            }

            // Fallback: just look for num_words
            const fallbackMatch = metadata.match(/"num_words"\s*:\s*(\d+)/);
            const relationMatch = metadata.match(/"relation"\s*:\s*"([^"]+)"/);
            if (fallbackMatch) {
                return {
                    value: parseInt(fallbackMatch[1]),
                    relation: relationMatch ? relationMatch[1] : 'equal to'
                };
            }

            return null;
        }

        // Check if actual word count meets the constraint
        function checkWordConstraint(actual, required, relation) {
            switch (relation) {
                case 'equal to': return actual === required ? 'pass' : 'fail';
                case 'at least': return actual >= required ? 'pass' : 'fail';
                case 'at most': return actual <= required ? 'pass' : 'fail';
                case 'less than': return actual < required ? 'pass' : 'fail';
                case 'more than': return actual > required ? 'pass' : 'fail';
                default: return actual === required ? 'pass' : 'fail';
            }
        }

        function validateCellOrder() {
            const issues = [];

            // Expected order of cell markers (simplified for main cells)
            const expectedOrder = [
                '**[system]**',
                '**[user]**',
                '**[thinking]**',
                '**[assistant]**',
                '**[turn_metadata]**',
                '**[validator_assistant]**',
                '**[validator_human]**'
            ];

            // Find positions
            const positions = [];
            expectedOrder.forEach(marker => {
                const pos = fileContent.indexOf(marker);
                if (pos !== -1) {
                    positions.push({ marker: marker.replace(/\*\*/g, ''), pos });
                }
            });

            // Check if positions are in ascending order
            for (let i = 1; i < positions.length; i++) {
                if (positions[i].pos < positions[i-1].pos) {
                    issues.push(`${positions[i].marker} before ${positions[i-1].marker}`);
                }
            }

            // Check turn_metadata comes before golden assistant (last assistant)
            const metaPos = fileContent.indexOf('**[turn_metadata]**');
            const lastAssistantMatch = [...fileContent.matchAll(/\*\*\[assistant\]\*\*/g)];
            if (lastAssistantMatch.length > 0 && metaPos !== -1) {
                const lastAssistantPos = lastAssistantMatch[lastAssistantMatch.length - 1].index;
                if (metaPos > lastAssistantPos) {
                    issues.push('turn_metadata should come before golden assistant');
                }
            }

            // Check validator_human comes after validator_assistant
            const vaPos = fileContent.indexOf('**[validator_assistant]**');
            const vhPos = fileContent.indexOf('**[validator_human]**');
            if (vaPos !== -1 && vhPos !== -1 && vhPos < vaPos) {
                issues.push('validator_human before validator_assistant');
            }

            return issues;
        }

        // Analysis
        async function startAnalysis() {
            if (!apiHandler || !apiHandler.hasApiKey()) {
                alert('API not configured. Check config.js');
                return;
            }

            if (!fileContent) {
                alert('Please upload a file first');
                return;
            }

            isAnalyzing = true;
            document.getElementById('upload-panel').classList.add('hidden');
            document.getElementById('progress-panel').classList.remove('hidden');
            document.getElementById('results-panel').classList.add('hidden');

            const progressBar = document.getElementById('progress-bar');
            const progressStatus = document.getElementById('progress-status');
            const logArea = document.getElementById('log-area');
            logArea.innerHTML = '';

            analysisResults = {};
            let completed = 0;

            for (const criterion of italianCriteria) {
                if (!isAnalyzing) break;

                progressStatus.textContent = `Analyzing: ${criterion.name}...`;
                addLog(`Checking ${criterion.name}...`, 'info');

                try {
                    // SMART: Replace {CONTEXT} with ONLY the cells needed for this criterion
                    const context = getContentForCriterion(criterion.id);
                    const prompt = criterion.prompt.replace('{CONTEXT}', context);

                    // Log token savings
                    console.log(`${criterion.id}: ~${Math.round(context.length / 4)} tokens (vs full file: ~${Math.round(fileContent.length / 4)})`);

                    const response = await apiHandler.callGemini(prompt);
                    const result = parseJSON(response.text);

                    analysisResults[criterion.id] = {
                        ...criterion,
                        rating: result.rating || 3,
                        feedback: result.feedback || response.text,
                        issues: result.issues || [],
                        passed: (result.rating || 3) >= criterion.min
                    };

                    const status = analysisResults[criterion.id].passed ? 'success' : 'error';
                    addLog(`${criterion.name}: ${result.rating}/5 ${analysisResults[criterion.id].passed ? '‚úì' : '‚úó'}`, status);

                } catch (error) {
                    // Check if it's a rate limit error
                    if (error.message.includes('Rate limit') || error.message.includes('429')) {
                        addLog(`‚è≥ Rate limit - aguardando e tentando novamente...`, 'info');
                        // Wait extra time and retry once more
                        await new Promise(r => setTimeout(r, 5000));
                        try {
                            const context = getContentForCriterion(criterion.id);
                            const prompt = criterion.prompt.replace('{CONTEXT}', context);
                            const response = await apiHandler.callGemini(prompt);
                            const result = parseJSON(response.text);
                            analysisResults[criterion.id] = {
                                ...criterion,
                                rating: result.rating || 3,
                                feedback: result.feedback || response.text,
                                issues: result.issues || [],
                                passed: (result.rating || 3) >= criterion.min
                            };
                            addLog(`${criterion.name}: ${result.rating}/5 (ap√≥s retry)`, 'success');
                            completed++;
                            continue;
                        } catch (retryError) {
                            addLog(`Error ap√≥s retry: ${retryError.message}`, 'error');
                        }
                    }

                    addLog(`Error: ${error.message}`, 'error');
                    analysisResults[criterion.id] = {
                        ...criterion,
                        rating: 0,
                        feedback: `Error: ${error.message}`,
                        issues: [error.message],
                        passed: false
                    };
                }

                completed++;
                const percent = Math.round((completed / italianCriteria.length) * 100);
                progressBar.style.width = percent + '%';
                progressBar.textContent = percent + '%';
            }

            if (isAnalyzing) {
                progressStatus.textContent = 'Analysis complete!';
                addLog('Analysis complete!', 'success');
                showResults();
            }
        }

        // SMART CELL SELECTION: Each criterion receives ONLY the cells it needs to evaluate
        // NO TRUNCATION on normal cells - read them fully. Only thinking cells can be limited.
        function getContentForCriterion(criterionId) {
            const system = extractedCells.system || '';
            const userAll = extractedCells.user_all_turns || extractedCells.user_final || '';
            const userFinal = extractedCells.user_final || '';
            const assistant = extractedCells.assistant || '';
            const metadata = extractedCells.turn_metadata || '';
            const validator = extractedCells.validator_assistant || '';
            const modelValidators = extractedCells.model_validators || '';
            const thinking = extractedCells.thinking || '';

            switch (criterionId) {
                case 'problem_framing':
                    // NEEDS: system + user_all_turns (to understand motivation)
                    return `=== SYSTEM MESSAGE ===\n${system}\n\n=== USER QUERIES (ALL TURNS) ===\n${userAll}`;

                case 'system_message':
                    // NEEDS: system ONLY (to evaluate Italian quality)
                    return `=== SYSTEM MESSAGE ===\n${system}`;

                case 'instruction_alignment':
                    // NEEDS: turn_metadata + user_final (to check constraints are explicit)
                    return `=== TURN METADATA (CONSTRAINTS) ===\n${metadata}\n\n=== USER QUERY (FINAL TURN) ===\n${userFinal}`;

                case 'factual_accuracy':
                    // NEEDS: user_all_turns + assistant (to verify no hallucination)
                    return `=== USER DATA (ALL TURNS) ===\n${userAll}\n\n=== GOLDEN RESPONSE ===\n${assistant}`;

                case 'response_formatting':
                    // NEEDS: assistant ONLY (to check preambles/closures)
                    return `=== GOLDEN RESPONSE ===\n${assistant}`;

                case 'dialogue_realisticness':
                    // NEEDS: system + user_final + assistant (to evaluate natural Italian feel)
                    return `=== SYSTEM ===\n${system}\n\n=== USER ===\n${userFinal}\n\n=== ASSISTANT ===\n${assistant}`;

                case 'model_breaking':
                    // NEEDS: model_validators ONLY (to check PASS/FAIL rates)
                    return `=== MODEL VALIDATOR RESULTS ===\n${modelValidators || validator || 'N/A'}`;

                case 'golden_perfection':
                    // NEEDS: assistant + turn_metadata + validator_assistant (to verify quality)
                    return `=== GOLDEN RESPONSE ===\n${assistant}\n\n=== CONSTRAINTS ===\n${metadata}\n\n=== VALIDATOR RESULTS ===\n${validator}`;

                default:
                    return 'N/A';
            }
        }

        function parseJSON(text) {
            const match = text.match(/\{[\s\S]*\}/);
            if (match) {
                try { return JSON.parse(match[0]); } catch (e) {}
            }
            return { rating: 3, feedback: text };
        }

        function addLog(message, type = 'info') {
            const log = document.getElementById('log-area');
            const time = new Date().toLocaleTimeString();
            log.innerHTML += `<div class="log-entry ${type}">[${time}] ${message}</div>`;
            log.scrollTop = log.scrollHeight;
        }

        function cancelAnalysis() {
            isAnalyzing = false;
            addLog('Cancelled by user', 'error');
        }

        function showResults() {
            document.getElementById('progress-panel').classList.add('hidden');
            document.getElementById('results-panel').classList.remove('hidden');

            const results = Object.values(analysisResults);
            const avgRating = results.length > 0
                ? (results.reduce((sum, r) => sum + (r.rating || 0), 0) / results.length).toFixed(1)
                : 0;
            const passed = results.filter(r => r.passed).length;
            const failed = results.filter(r => !r.passed).length;

            // Verdict
            let verdict, verdictClass, message;
            if (failed === 0) {
                verdict = '‚úÖ APPROVED';
                verdictClass = 'approved';
                message = 'All criteria meet minimum requirements!';
            } else if (failed <= 2) {
                verdict = '‚ö†Ô∏è MINOR REVISION';
                verdictClass = 'revision';
                message = `${failed} criteria below minimum`;
            } else {
                verdict = '‚ùå MAJOR REVISION';
                verdictClass = 'rejected';
                message = `${failed} criteria below minimum`;
            }

            const summaryBox = document.getElementById('summary-box');
            summaryBox.className = 'summary-box ' + verdictClass;
            document.getElementById('verdict-text').textContent = verdict;
            document.getElementById('verdict-message').textContent = message;
            document.getElementById('stat-avg').textContent = avgRating;
            document.getElementById('stat-pass').textContent = passed;
            document.getElementById('stat-fail').textContent = failed;

            // Results list
            document.getElementById('results-list').innerHTML = results.map(r => `
                <div class="result-card">
                    <div class="result-header" onclick="toggleResult('${r.id}')">
                        <span style="font-weight: bold;">${r.name}</span>
                        <div>
                            <span class="badge ${r.passed ? 'badge-pass' : 'badge-fail'}">${r.passed ? 'PASS' : 'FAIL'}</span>
                            <span class="rating-badge rating-${r.rating}">${r.rating}/5</span>
                        </div>
                    </div>
                    <div class="result-content" id="result-${r.id}">
                        <p style="color: #888; margin-bottom: 10px;">Minimum: ${r.min}</p>
                        <div class="result-feedback">${r.feedback}${r.issues?.length ? '\n\nIssues:\n- ' + r.issues.join('\n- ') : ''}</div>
                    </div>
                </div>
            `).join('');

            // Generate feedback
            generateFeedback();
            updateApiStatus();
        }

        function toggleResult(id) {
            document.getElementById('result-' + id).classList.toggle('active');
        }

        function generateFeedback() {
            // Initial auto-generated feedback
            generateFinalFeedback();
        }

        function generateFinalFeedback() {
            const results = Object.values(analysisResults);
            const failed = results.filter(r => !r.passed);
            const difficulty = document.getElementById('difficulty-select').value;
            const difficultyReason = document.getElementById('difficulty-reason').value || 'N/A';
            const reviewTime = document.getElementById('review-time').value || '15';

            // Determine verdict
            let verdict;
            if (failed.length === 0) {
                verdict = 'APPROVED';
            } else if (failed.length <= 2) {
                verdict = 'MINOR REVISION';
            } else {
                verdict = 'MAJOR REVISION';
            }

            // Build feedback in requested format
            let feedback = `## TASK REVIEW: ${fileName.replace('.py', '').split('_').pop()}\n\n`;
            feedback += `### CRITERIA RATINGS:\n\n`;
            feedback += `| # | Criterion | Rating | Comment |\n`;
            feedback += `|---|-----------|--------|--------|\n`;

            results.forEach((r, i) => {
                const shortComment = r.feedback ? r.feedback.split('.')[0] : 'N/A';
                feedback += `| ${i + 1} | ${r.name} | **${r.rating}** | ${shortComment} |\n`;
            });

            feedback += `\n---\n\n`;
            feedback += `**Difficulty:** ${difficulty}\n\n`;
            feedback += `**Reason:** ${difficultyReason}\n\n`;

            feedback += `**Feedback Summary:** `;
            if (failed.length === 0) {
                feedback += `All criteria meet minimum requirements. Task is well-constructed.\n\n`;
            } else {
                feedback += `${failed.length} criteria below minimum. Issues: ${failed.map(f => f.name.split('(')[0].trim()).join(', ')}.\n\n`;
            }

            feedback += `**Review Time:** ${reviewTime} minutes\n\n`;
            feedback += `**Verdict:** ${verdict}\n`;

            document.getElementById('feedback-output').textContent = feedback;
        }

        function copyFeedback() {
            navigator.clipboard.writeText(document.getElementById('feedback-output').textContent);
            alert('Copied!');
        }

        function resetTool() {
            document.getElementById('upload-panel').classList.remove('hidden');
            document.getElementById('progress-panel').classList.add('hidden');
            document.getElementById('results-panel').classList.add('hidden');
            document.getElementById('file-info').classList.add('hidden');
            document.getElementById('file-input').value = '';
            document.getElementById('progress-bar').style.width = '0%';
            fileContent = '';
            fileName = '';
            extractedCells = {};
            analysisResults = {};
        }

        // Drag and drop
        const uploadZone = document.querySelector('.upload-zone');
        uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.style.borderColor = '#4ecca3'; });
        uploadZone.addEventListener('dragleave', () => { uploadZone.style.borderColor = ''; });
        uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            uploadZone.style.borderColor = '';
            const file = e.dataTransfer.files[0];
            if (file?.name.endsWith('.py')) {
                document.getElementById('file-input').files = e.dataTransfer.files;
                handleFileUpload({ target: { files: [file] } });
            }
        });
    </script>
</body>
</html>
